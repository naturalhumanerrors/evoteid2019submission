(*	In this file, the set of restrictions are generated and written in 
	the appropriate files.
*)

open Write_restrictions;;
open List;;
open Array;;
open Compare_restriction;;
open ASD_tam;;

(*	This list contains the strings that appear in the protocol that 
	will be used to generate the restrictions.
*)
let l_string = ["vote";"key";"secret"];;

(*	The type rslt refers to what lemma a set of restrictions would 
	ensure:
	-OK if every lemma is verified.
	-TooLong d if the computation was interrupted because it took 
	 longer than d seconds.
	-NoFunctionnal id if at least one functionnality lemma (that is, 
	 with "exists-trace") is falsified), where id corresponds to the 
	 number of the set of restrictions from which we could deduce that 
	 it does not ensure a functionnality lemma.
	-NoSecurity (id,d) if every functionnality lemma is verified but at 
	 least one security lemma (that is, with "all-traces") is not 
	 verified. id corresponds to the number of the set of restrictions 
	 from which we could deduce that it does not ensure a security 
	 lemma. d corresponds to the 'score' of that set of restriction:
		-1000 for every security lemma ensured.
		-d for every security lemma that is falsified in d steps.
*)
type rslt = 
	| OK 
	| TooLong of float
	| NoFunctionnal of int
	| NoSecurity of int * int 
;;
 
type node = 
	{ rstr : set_restr; 
	  r_to_write : bodys;
	  (* less_traces contains the index of every set of restrictions 
	  for which the set of traces allowed is included in the of traces 
	  allowed by rstr *)
	  mutable less_traces : int list;
	  (* more_traces contains the index of every set of restrictions 
	  for which the set of traces allowed includes the of traces 
	  allowed by rstr *)
	  mutable more_traces : int list;
	  index : int;
	  mutable visited : bool;
	  mutable score : rslt option }
;;

let l_tm = 
	let rec map l f = match l with
		| [] -> []
		| a::suite -> (f a)::(map suite f)
	in
	let create_apos x = Apos(x) in
	map l_string create_apos
;;
(*
let l_tm = [Apos("vote");Apos("key");Apos("secret")];;
*)
(*	This function generates the restrictions of the form:
		-Learn() @k ==> From() @k
		-Receive() @k ==> From() @k
		-Send() @k ==> To() @k
	Only these restrictions are usefull for the simple voting protocol.
*)
let lf_rf_st () = 
  let res_lf = ref [] 
  and res_rf = ref [] 
  and res_st = ref [] 
  in
  
  let l = Array.of_list (Common("tm") :: l_tm) in
  let n = Array.length l in
  for i = 0 to n-1 do
    let tm = Array.get l i in
    res_lf := (LF tm) :: !res_lf;
    res_rf := (RF tm) :: !res_rf;
    res_st := (ST tm) :: !res_st;
  done;
  (!res_lf,!res_rf,!res_st)
;;

(*	This function generates the restrictions of the form:
		-Receive('type',message) @k & From() @k ==> 
		Send('type', message) @i & To()@i & i < k
		-Send('type',message) @k & To() @k ==> 
		Receve('type', message) @i & From()@i & i < k
	These restrictions are not used for the simple voting protocol.
*)
let rs_sr () = 
  let res_rs = ref [] 
  and res_sr = ref [] 
  in

  let l = Array.of_list l_tm in
  let n = Array.length l in
  for i = 0 to n-1 do
    for j = 0 to n-1 do
      let tm1 = Array.get l i 
      and tm2 = Array.get l j
      in
      if (tm1 = tm2)
      then (
      res_rs := (RS (tm1,tm2,true)) :: !res_rs;
      res_sr := (SR (tm1,tm2,true)) :: !res_sr
      )
      else (
      res_rs := (RS (tm1,tm2,false)) :: !res_rs;
      res_sr := (SR (tm1,tm2,false)) :: !res_sr
      )
    done
  done;
  (!res_rs,!res_sr)
;;

(*	This function generates the restrictions of the form:
		-Receive('type1',message1) @k & From() @k ==> 
		Receive('type2', message2) @i & From()@i & i < k
		-Send('type1',message1) @k & To() @k ==> 
		Send('type2', message2) @i & To()@i & i < k
	These restrictions are not used for the simple voting protocol.
*)
let rr_ss () = 
  let res_rr = ref [] 
  and res_ss = ref [] 
  in

  let l = Array.of_list l_tm in
  let n = Array.length l in
  for i = 0 to n-1 do
    for j = (i+1) to n-1 do
      let tm1 = Array.get l i 
      and tm2 = Array.get l j
      in
      res_rr := (RR (tm1,tm2)) :: !res_rr;
      res_rr := (RR (tm2,tm1)) :: !res_rr;
      res_ss := (SS (tm1,tm2)) :: !res_ss;
      res_ss := (SS (tm2,tm1)) :: !res_ss;
    done
  done;
  (!res_rr,!res_ss)
;;

(*	This function gathers all restrictions that will be used to 
	generate all the set of restriction(s). See the descriptions of the 
	functions lf_rf_st, rs_sr and rr_ss for the kind of restriction 
	that is generated. 
	
	The set of restrictions that will be generated with the function 
	write_and_design contains one, two or three restrictions with, 
	at most, one restriction coming from each array t0,t1,t2 and t3.
	
	Currently, only the restrictions generated by lf_rf_st are used. To 
	change that, one can modify the definition of t0,t1,t2 and t3. 
	For instance:
		"let t0 = Array.of_list l0  
		and t1 = Array.of_list (l1 @ l2)
		and t2 = Array.of_list (l3 @ l4)
		and t3 = Array.of_list (l5 @ l6)
		in"
	would lead to have every restrictions from all three functions in 
	the generation of the set of restrictions. 
*)
let design_restrictions () = 
  let (l0,l1,l2) = lf_rf_st ()
(*
  and (l3,l4) = rs_sr ()
  and (l5,l6) = rr_ss ()
*)
  in  
  let t0 = Array.of_list l0  
  and t1 = Array.of_list l1 
  and t2 = Array.of_list l2
  and t3 = Array.of_list []
  in
  (t0,t1,t2,t3)
;;

let rec inter l1 l2 = match l1 with
	| [] -> -1
	| a :: suite -> if (find l2 a) then a else (inter suite l2)
and find l i = match l with
	| [] -> false
	| x::suite -> if (x=i) then true else (find suite i)
;;

let get_pair t i j = 
	let l1 = (Array.get t i).less_traces
	and l2 = (Array.get t j).less_traces
	in
	let n = inter l1 l2 in
	n
;;

let rec add_list x l = match l with
	| [] -> [x]
	| a :: suite -> if (x = a) then l else a :: (add_list x suite)
;;

let make_node lx lr id = 
	let r = 
	match lx with
		| [x] -> OneRestr(x)
		| [x1;x2] -> TwoRestr(x1,x2)
		| [x1;x2;x3] -> ThreeRestr(x1,x2,x3)
		| _ -> failwith "incorrect lists!"
	in
	let n = { 	rstr = r; 
				r_to_write = lr;
				more_traces = [];
				less_traces = []; 
				index = id;
				visited = false;
				score = None } in
	n
;;

(*	This function generates all the set of one, two and three 
	restrictions from the restrictions of interest. 
	
	For every set of restrictions s, the two lists s.less_traces and 
	s.more_traces are also computed.
*)
let write_and_design f ast = 
	let dest_restr = f^"Restriction/Restriction_" 
	and id = ref 0
	and l = ref [] 
	and l_restr = ref [] 
	and (theory,body) = ast 
	in
	
	let make_one a z =
		let k = Array.length a in
		for i = 0 to k-1 do
			let x = Array.get a i in
			let (ra,rb,n) = translate x in
			let r = make_restriction ra rb n (z+i) in
			
			l_restr := r :: !l_restr;
			
			let n = make_node [x] [r] !id in
			l := n :: !l;
			
			pretty_printer (dest_restr^(string_of_int !id)^".spthy") (theory,body @ [r]);
			id := !id + 1;
		done
	in
	let make_two a1 a2 z1 z2 = 
		let k1 = Array.length a1
		and k2 = Array.length a2
		in
		for i1 = 0 to k1-1 do
			for i2 = 0 to k2-1 do
				let x1 = Array.get a1 i1 in
				let (r1a,r1b,n1) = translate x1 in
				let r1 = make_restriction r1a r1b n1 (z1+i1) in
				
				let x2 = Array.get a2 i2 in
				let (r2a,r2b,n2) = translate x2 in
				let r2 = make_restriction r2a r2b n2 (z2+i2) in

				let n12 =  make_node [x1;x2] [r1;r2] !id in
								
				l := n12 :: !l;
				pretty_printer (dest_restr^(string_of_int !id)^".spthy") (theory,body @ [r1;r2]);
				id := !id + 1
			done
		done
	in
	let make_three a1 a2 a3 z1 z2 z3 = 
		let k1 = Array.length a1
		and k2 = Array.length a2
		and k3 = Array.length a3
		in
		for i1 = 0 to k1-1 do
			for i2 = 0 to k2-1 do
				for i3 = 0 to k3-1 do
					let x1 = Array.get a1 i1 in
					let (r1a,r1b,n1) = translate x1 in
					let r1 = make_restriction r1a r1b n1 (z1+i1) in
					
					let x2 = Array.get a2 i2 in
					let (r2a,r2b,n2) = translate x2 in
					let r2 = make_restriction r2a r2b n2 (z2+i2) in
					
					let x3 = Array.get a3 i3 in
					let (r3a,r3b,n3) = translate x3 in
					let r3 = make_restriction r3a r3b n3 (z3+i3) in

					let n123 =  make_node [x1;x2;x3] [r1;r2;r3] !id in
									
					l := n123 :: !l;
					pretty_printer (dest_restr^(string_of_int !id)^".spthy") (theory,body @ [r1;r2;r3]);
					id := !id + 1
				done
			done
		done
	in
	
	let (t1,t2,t3,t4) = design_restrictions () in
	let k1 = Array.length t1
	and k2 = Array.length t2
	and k3 = Array.length t3
	and k4 = Array.length t4
	in
	let nb_set_restr = 
		k1+k2+k3+k4+
		(k1*k2)+(k1*k3)+(k1*k4)+(k2*k3)+(k2*k4)+(k3*k4)+
		(k1*k2*k3)+(k1*k2*k4)+(k1*k3*k4)+(k2*k3*k4) 
	in
	print_string ("Total number of set of restriction(s): "^(string_of_int nb_set_restr)^".\n\n");
	
	make_one t1 0;
	make_one t2 k1;
	make_one t3 (k1+k2);
	make_one t4 (k1+k2+k3);
	make_two t1 t2 0 k1;
	make_two t1 t3 0 (k1+k2);
	make_two t1 t4 0 (k1+k2+k3);
	make_two t2 t3 k1 (k1+k2);
	make_two t2 t4 k1 (k1+k2+k3);
	make_two t3 t4 (k1+k2) (k1+k2+k3);
	make_three t1 t2 t3 0 k1 (k1+k2);
	make_three t1 t2 t4 0 k1 (k1+k2+k3);
	make_three t1 t3 t4 0 (k1+k2) (k1+k2+k3);
	make_three t2 t3 t4 k1 (k1+k2) (k1+k2+k3);
	
	pretty_printer (f^"All_restrictions_.spthy") ("restrictions",!l_restr);
	
	let t = Array.of_list (List.rev !l) in
	let u = Array.length t in
	for i = 0 to u-1 do
		for j = i+1 to u-1 do
			let xi = (Array.get t i)
			and xj = (Array.get t j)
			in
			if (compare_set xi.rstr xj.rstr)
			then (xi.less_traces <- add_list j xi.less_traces; xj.more_traces <- add_list i xj.more_traces);
			if (compare_set xj.rstr xi.rstr)
			then (xj.less_traces <- add_list i xj.less_traces; xi.more_traces <- add_list j xi.more_traces);
		done
	done;
	
	let origin = ref [] in
	for i = 0 to (k1+k2+k3+k4-1) do
		origin := i :: !origin
	done;
	(!origin,t)
;;
